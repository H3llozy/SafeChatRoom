#加密局域网聊天室
###系统功能流程
	首先在服务器上有公钥和私钥，在客户端上都有服务器上的私钥。
###注册流程：
服务器端启动服务器，开启一个线程，不断的接受客户端发送过来的信息。
客户端注册用户，填写用户名，密码，确定密码（对用户名，密码，确认密码为空进行了判断，并且对密码和确认密码进行了校对并且进行相关的提示）点击注册后，客户端将用户名，密码和用户操作的类型（登录，注册）封装为一个javaBean（User对象）。同时，客户端生成公钥和私钥，然后通过客户端上存储的服务器的公钥对客户端生成的公钥进行RAS加密生成加密的密钥，并设置给User对象中的key的数据,然后通过对象流，将这个User对象传送给服务器端。


服务器端接受到客户端发送过来的User对象，通过User对象的getType（）方法获取用户的操作类型。通过获取得知用户是注册操作，然后通过后台的数据库操作类对User对象进行解析和对数据库的信息进行匹配，如果用户名已经存在，或者操作数据库失败，则返回false，如果添加用户信息成功，则返回true。同时，服务器获取到了User对象中的key的值，然后用服务器的私钥，对这个key进行RAS解密，生成客户端的公钥，并保存到文件中去，服务器端通过返回的结果将数据封装入一个javaBean（Message对象），Message类指定信息的类型（通过接口MessageType对类型进行定义），信息的内容和信息的发送时间、信息的发送者和信息的接受者。服务器端将Message对象通过对象流的形式又发送给客户端。
客户端接受到服务器端发送过来的Message对象，通过getMessageType（）得知信息的类型，并进行相应的操作。得知发送过来的类型是注册成功类型，客户端会提示注册成功（如果是注册失败的类型，则客户端会返回注册失败）


----------


###登陆流程：
客户端通过注册后的用户名和密码进行登录操作。（对用户名和密码为空进行了判断和提示）。客户端又会将用户名和密码和操作类型（登录类型）封装为User对象，传送给客户端。
服务器端接受到客户端发送过来的User对象，获取用户的操作类型，得知用户的是登录类型，然后通过后台的数据库操作类对User对象进行解析和对数据库的信息进行匹配，如果数据库有符合的用户，则放回true否则返回false。服务器端将返回的信息封装为Message对象，指定其类型为登录成功（或登录失败），然后通过对象流传给客户端。如果是登录成功，则服务器端会专门开一条线程为登录成功的这个用户进行服务，专门接受这个客户端的信息。并将这个线程放入一个专门管理线程的集合（通过这个集合可以对线程进行随时的读取）。
客户端接受到服务器发送过来的Message对象，通过Message的类型进行相应的操作（登录成功的类型，客户端提示登录成功并进去群聊界面，并将这个群聊界面放入一个专门管理群聊界面的集合（通过这个集合可以将信息显示在特定的群聊界面上）；登录失败的类型，则客户端提示登录失败）。登录成功后，客户端登陆成功之后，客户端通过发送信息（指定信息类型）提醒服务器端修改在线用户和在线人数，服务器再提醒所有用户修改在线用户和在线人数，然后客户端开启一个专门接受信息的线程。


----------

###群发信息：
客户端通过文本域输入信息，然后将信息内容，信息发送的时间，信息的发送者（所有人）信息的发送者，信息的类型（群发消息）封装为一个Message对象，然后通过UUID生成唯一的全球唯一的字符串，用它来作为AES加密的KEY，用这个KEY对发送的消息进行AES加密，然后用服务器的公钥对这个KEY进行RAS加密，存刀Message对象中的key属性中去，然后通过对象流传送给服务器。
服务器端通过信息的类型（群发消息）进行操作，然后取出专门管理线程的集合里的每一个元素，获得每一个与客户端连接的线程，然后把信息转发给每一个在线用户。

----------


###群发文件：
客户端点击发送文件，打开文件选择器，选择好文件，客户端通过UUID生成唯一的全球唯一的字符串，对文件进行加密读取，然后对KEY进行服务器公钥的RAS加密，然后客户端将加密文件的名字和发送者和信息类型（群发文件）等信息封装入Message对象中，发送给服务器端。并且将文件发送给服务器。
服务器端解析发送过来的信息类型（群发文件），然后取出从集合中取出所有与客户端连接的线程，将文件转发给每个在线用户。并发送系统消息：（发送者）给所有人发送了（文件名）文件。

----------


###单人聊天：
客户端选择用户点击单人聊天（不能和自己聊天）。弹出单人聊天界面，在文本域里输入信息，点击发送。客户端通过UUID生成唯一的全球唯一的字符串，用它来作为AES加密的KEY，用这个KEY对发送的消息进行AES加密，然后用服务器的公钥对这个KEY进行RAS加密，客户端将信息和KEY封装入Message对象，并指定类型为单人聊天，指定发送者和接受者。
服务器端收到客户端发送过来的Message对象，解析Message对象，得到接受者，通过接受者找到集合中对应的线程，取出来并转发消息。


----------

单人发送文件
客户端在单人聊天界面点击发送文件，打开文件选择器，选择好文件客户端通过UUID生成唯一的全球唯一的字符串，对文件进行加密读取，然后对KEY进行服务器公钥的RAS加密，客户端将加密的文件的名字和发送者、接受者和信息类型（单人发送文件）等信息封装入Message对象中，发送给服务器端。并且将文件发送给服务器。
服务器端接收到客户端发送过来的Message对象，并进行解析，得知接受者是谁，然后从集合中取出对应的线程，然后将文件转发给用户。

----------

###聊天信息和文件的转发：
获取到客户端传过来的加密KEY，用服务器私钥对其进行RAS解密，然后根据转发对象的公钥对其再次进行RAS加密，然后对加密聊天信息或文件发送到对应用户页面中

----------

###具体加密方法
RSA算法是公开密钥系统的代表，其安全性建立 在具有大素数因子的合数，其因子分解困难这一法则之上的。Rijndael算法作为新一代的高级加密标准，运行时不需要计算机有非常高的处理能力和大的内 存，操作可以很容易的抵御时间和空间的攻击，在不同的运行环境下始终能保持良好的性能。这使AES将安全，高效，性能，方便，灵活性集于一体，理应成为网 络数据加密的首选。相比较，因为AES密钥的长度最长只有256比特，可以利用软件和硬件实现高速处理，而RSA算法需要进行大整数的乘幂和求模等多倍字 长处理，处理速度明显慢于AES；所以AES算法加解密处理效率明显高于RSA算法。在密钥管理方面，因为AES算法要求在通信前对密钥进行秘密分 配，解密的私钥必须通过网络传送至加密数据接收方，而RSA采用公钥加密，私钥解密（或私钥加密，公钥解密），加解密过程中不必网络传输保密的密钥；所以 RSA算法密钥管理要明显优于AES算法。 
从上面比较得知，由于RSA加解密速度慢，不适合大量数据文件加密，因此在网络中完全用公开密码体制传 输机密信息是没有必要，也是不太现实的。AES加密速度很快，但是在网络传输过程中如何安全管理AES密钥是保证AES加密安全的重要环节。这样在传送 密信息的双方，如果使用AES对称密码体制对传输数据加密，同时使用RSA不对称密码体制来传送AES的密钥，就可以综合发挥AES和RSA的优点同时避 免它们缺点来实现一种新的数据加密方案。加解密实现流程如下图。 

![image](https://github.com/cckevincyh/SafeChatRoom/blob/master/img/img2.png)
----------

###具体过程：用AES给消息和文件加密，用RAS给AES的key进行加密，将RAS加密后的KEY和AES加密后的消息一起发送出去。




----------


###加密后的服务器显示
![image](https://github.com/cckevincyh/SafeChatRoom/blob/master/img/img1.png)
